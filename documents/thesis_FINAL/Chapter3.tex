% Introduction

% Main chapter title
\chapter{Generation of different LDPC matrices} 

% Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}
\label{Chapter2} 

% This is for the header on each page
\lhead{Chapter 2. \emph{Generation of different LDPC matrices}}  

The Bit Error Rate of decoded code word depends upon properties of parity check matrix. A good parity check matrix should be sparse and  it should have good girth.  

Basic parameters to decide the formation of parity check matrix are as follows . 
\begin{itemize}
\item  \textbf{Random parity check matrix vs systematic parity check matrix:} Parity check matrix that has a specific method of filling $1s$ in matrix is called systematic parity check matrix, else if the position of $1s$ is random, the matrix is called random parity check matrix.
\item\textbf{Regular parity check matrix vs irregular parity check matrix:} Regular parity check matrix has constant number of $1s$ in row and columns, whereas irregular parity check matrix has variable number of $1s$ in its rows and columns. \\
	If $w_c$ is number of $1s$ in a column and $w_r $ is number of $1s$ in a row then in a m$\times$ n regular parity check matrix
\begin{align}
 m * ( w_r ) = n * ( w_c )  
\end{align}
%Collectively the set
%v and h is called the degree distribution of the code. 
%\item columns are divided in $w_r$ sets n/$w_r$ columns in each set. 
If we take the fraction of columns
of weight i by $v_i$ and the fraction of rows of weight i by $h_i$ then in a irregular parity check matrix
\begin{align} m * \sum_{i} (h_i*i) = n *\sum_{i} (v_i*i) 
\end{align}


\end{itemize} 
%\renewcommand{\labelitemi}{$\square$}
\section{Gallager Parity Check Matrix}
Gallager proposed parity check matrix is regular in nature\cite{1}. A regular matrix has constant number of non-zero entries in a row and a column. 
These are represented as (n,$w_c$,$w_r$) codes. where,
\\
$w_c$ = Number of 1\textsuperscript{'}s in a column 
\\
$w_r$ = Number of 1\textsuperscript{'}s in a row 
\\
n = Block length. \\
\textbf{Method of construction:} \\
\noindent o Divide rows in $w_c$ sets with ( m / $w_c$ ) rows in each set.  \\
%\item columns are divided in $w_r$ sets n/$w_r$ columns in each set. 
o All rows of first set of rows contain $w_r$ consecutive once ordered from left to right. \\
o Every other set of rows is random column permutation of first set of rows. \\
\textbf{Example of Gallager Matrix:} \\
( n , $w_c$ , $w_r$ ) = ( 12 , 3 , 4 ) ; m = 9 
\[
 H=
 \left[ \begin{array}{cccccccccccc}
1 &  1 &  1  & 1 &  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 &  1 &  1  & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 &  1 &  1  & 1 \\
-& - & - & - & - & - & - & - & - &  - &  -  & -\\ 
1 &  0 &  1  & 0 &  0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 &  0 &  1  & 1 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 &  0 &  1  &  0\\
-& - & - & - & - & - & - & - & - &  - &  -  & -\\ 
1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 1 & 0 \\
0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\ \end{array} \right]  
\]


\section{Quasi-Cyclic (QC) parity Check Matrix}
QC matrix can be constructed by 
Sridhara Fuja Tanner (SFT)\cite{3} method is discussed. Performance of quasi-cyclic codes is better for smaller block length, comparable for moderate block length with respect to random-regular codes.\\
Method of Construction of (j,k)-regular QC-LDPC code:
\begin{itemize}
\item Construct two sequences $\{s_1,s_2,...,s_{j-1}\}$ and $\{t_1,t_2,...,t_{k-1}\}$, whose elements are randomly selected from GF(p), where p is prime and p$>$2 , $s_i \neq s_x \ \& \ t_i \neq t_x$ if i $\neq$x.
\item Now, form a preliminary matrix Y with the elements of GF(p) as follows:
\begin{align}
 E= \left[ \begin{array}{cccc}
e_{0,0} & e_{0,1} & \cdots & e_{0,k-1} \\
e_{1,0} & e_{0,1} & \cdots & e_{0,k-1} \\
\vdots & \vdots & \ddots & \vdots \\
e_{j-1,0} & e_{j-1,1} & \cdots & e_{j-1,k-1} 
\end{array} \right] 
\end{align}
 
where (i,j)th element of E is calculated by following quadratic congruential equation for a fix parameter
$\kappa\epsilon\{1,2,...,p-1\} $ and $\nu_i,\nu_j\epsilon\{1,2,...,p-1\} $: 
\begin{align}
 e_{i,j}=[\kappa(s_i+t_j)^2 + \nu_i +\nu_j] 
\end{align}
\item So the parity check matrix H is represented by jXk array of circulant permutation of identity matrix. 
\[
 H= \left[ \begin{array}{cccc}
I(e_{0,0}) & I(e_{0,1}) & \cdots & I(e_{0,k-1}) \\
I(e_{1,0}) & I(e_{0,1}) & \cdots & I(e_{0,k-1}) \\
\vdots & \vdots & \ddots & \vdots \\
I(e_{j-1,0}) & I(e_{j-1,1}) & \cdots & I(e_{j-1,k-1}) 
\end{array} \right] \]

 
Where I(x) is p$\times$p identity matrix with row cyclically shifted right by x position.
\end{itemize}

\section{MacKay Neal Parity Check Matrix}
Mckey Neal proposed regular (n,$w_c$,$w_r$) construction of codes using random distribution of non-zero entries\cite{2}. These codes have better performance for large block length compared to other codes.
Method of construction:
\begin{itemize} 
\item Start from the first column. Place $w_c$ 1s in the column randomly and track number of 1s in a row.
\item Repeat the process for other columns. Break only if at any point number of 1\textsuperscript{'}s in the row becomes greater than $w_r$.
\item If break occurs then go back to some columns and repeat algorithm till all columns get filled.
\end{itemize} 
\textbf{Example:}\\
 n = 12, m = 9  
  \[H=
 \left[ \begin{array}{cccccccccccc}
1 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\
0 & 0 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0\\
1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\ \end{array} \right]  
\] 

MacKay Neal construction can be adapted to avoid cycles of length 4, called 4-cycles.\\
Method to avoid 4-cycles\cite{7}:
\begin{itemize}
\item First, generate a preliminary parity check matrix.
\item Put 1s to parity check matrix in rows that don't have any 1s in them or that have only one 1. The places where 1s are to be added in those rows are selected randomly. 
\item Choose odd number of 1s to put in a column. If preliminary parity check matrix constructed has an even number of 1s in each column, problem may occur that will cause the rows to sum up to zero, and hence at least one check will become redundant.
\item To remove situation that has a pair of columns both have all 1s in a particular pair of rows, that makes cycles of length four in graph, one of the 1s involved is moved randomly within its column.
\end{itemize}
Eliminating the cycles improves the girth of the graph and thus improves the convergence and make the iterative decoding faster.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
