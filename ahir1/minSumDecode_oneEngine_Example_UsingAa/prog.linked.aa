$pipe  Nitr_required : $uint<8>  $depth 1 
// can point into 
$storage  aPosteriori : $array[13000] $of $float<8,23> // memory space index = 3  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  aPriori : $array[13000] $of $float<8,23> // memory space index = 2  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  code_block : $array[13000] $of $float<8,23> // memory space index = 1  base address = 0  word size = 32
// can point into 
$pipe  code_block_in : $float<8,23>  $depth 2 
// can point into 
$pipe  code_block_out : $float<8,23>  $depth 1 
// can point into 
$pipe  ebbyNo_in : $float<8,23>  $depth 1 
// can point into 
$storage  ext_info : $array[60000] $of $float<8,23> // memory space index = 5  base address = 0  word size = 32
// can point into  foreign( $void )
$pipe  matrix_in : $uint<16>  $depth 2 
// can point into 
$pipe  maxNitr_in : $uint<16>  $depth 1 
// can point into 
$storage  mem : $array[60000] $of $uint<16> // memory space index = 0  base address = 0  word size = 16
// can point into 
$storage  message : $array[60000] $of $float<8,23> // memory space index = 4  base address = 0  word size = 32
// can point into  foreign( $void )
$pipe  rate_in : $float<8,23>  $depth 1 
// can point into 
$module [checkIsdecoded]
$in ( ncols : $uint<16>  )
$out ( is_decoded : $uint<1>  )
$is
{
  $storage  is_decoded_temp : $uint<1> // memory space index = 12  base address = 0  word size = 1
  // can point into 
  is_decoded_temp := 1 
  ncols_minus_1 := (ncols - 1 )
  $branchblock [checkIsdecoded_loop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    c_aPosteriori := (aPosteriori[I] > 0 )
    c_code_block := (code_block[I] < 0 )
    c_is_decoded0_1 := (( ~ c_code_block ) & c_aPosteriori)
    c_is_decoded0_2 := (( ~ c_aPosteriori ) & c_code_block)
    c_is_decoded0 := (c_is_decoded0_1 | c_is_decoded0_2)
    $guard (c_is_decoded0) is_decoded_temp := 0 
    $guard (c_code_block) code_block[I] := _f1.00e+0
    $guard ( ~ c_code_block) code_block[I] := _f-1.00e+0
    $while (I < ncols_minus_1)
  }
  is_decoded := is_decoded_temp
}
$module [checkNodeComputeEngine]
$in ( ncol_ind : $uint<16>   nrows : $uint<16>  )
$out ()
$is
{
  $storage  val : $float<8,23> // memory space index = 6  base address = 0  word size = 32
  // can point into  foreign( $void )
  $storage  sign : $float<8,23> // memory space index = 7  base address = 0  word size = 32
  // can point into 
  $storage  flag : $uint<1> // memory space index = 8  base address = 0  word size = 1
  // can point into 
  $storage  exor : $uint<1> // memory space index = 9  base address = 0  word size = 1
  // can point into 
  $storage  range : $uint<16> // memory space index = 10  base address = 0  word size = 16
  // can point into  foreign( $void )
  $storage  temp1 : $float<8,23> // memory space index = 11  base address = 0  word size = 32
  // can point into  foreign( $void )
  nrows_minus_1 := (nrows - 1 )
  $branchblock [checkNodeComputeEngine_loop1]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi row := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  Nrow $on $loopback // type of target is $uint<16>
    $endmerge
    Nrow := (row + 1 )
    temp00 := (3  + ncol_ind)
    temp01 := (temp00 + row)
    CHECK_BIT_COUNT1 := (ncol_ind - (mem[temp01] - 1 ))
    temp10 := (3  + ncol_ind)
    temp11 := (temp10 + row)
    temp12 := (1  + temp11)
    CHECK_BIT_COUNT2 := (mem[temp12] - mem[temp11])
    condition_range := (row == nrows_minus_1)
    $guard (condition_range) range := CHECK_BIT_COUNT1
    $guard ( ~ condition_range) range := CHECK_BIT_COUNT2
    range_minus_1 := (range - 1 )
    $branchblock [checkNodeComputeEngine_loop2]
    {
      $dopipeline $depth 7 $buffering 1
      $merge $entry $loopback 
      $phi col := 				  ($bitcast ($uint<16>) 0  ) $on $entry				  Ncol $on $loopback // type of target is $uint<16>
      $endmerge
      Ncol := (col + 1 )
      temp20 := (3  + ncol_ind)
      temp21 := (temp20 + row)
      index_2D := ((mem[temp21] - 1 ) + col)
      val := _f0.00e+0
      sign := _f0.00e+0
      flag := 0 
      exor := 0 
      $branchblock [checkNodeComputeEngine_loop3]
      {
        $dopipeline $depth 7 $buffering 1
        $merge $entry $loopback 
        $phi I := 					  ($bitcast ($uint<16>) 0  ) $on $entry					  NI $on $loopback // type of target is $uint<16>
        $endmerge
        NI := (I + 1 )
        index := ((mem[((3  + ncol_ind) + row)] - 1 ) + I)
        mod_temp30 := (message[index] * ($bitcast ($float<8,23>) _f-1.00e+0 ))
        condition_message := (message[index] < 0 )
        $guard (condition_message) temp1 := mod_temp30
        $guard ( ~ condition_message) temp1 := message[index]
        condition_I := (I == col)
        condition_flag := (flag == 0 )
        condition_swap := (temp1 < val)
        condtion_exor_1 := (( ~ condition_I ) & condition_message)
        condtion_val_init := (( ~ condition_I ) & condition_flag)
        condtion_val_swap_par := (( ~ condition_I ) & condition_swap)
        condtion_val_swap := (( ~ condition_flag ) & condtion_val_swap_par)
        $guard (condtion_exor_1) exor := (exor ^ 1 )
        $guard (condtion_val_init) val := temp1
        $guard (condtion_val_init) val := temp1
        flag := 1 
        $while (I < range_minus_1)
      }
      condition_sign := (exor == 0 )
      $guard (condition_sign) sign := _f1.00e+0
      $guard ( ~ condition_sign) sign := _f-1.00e+0
      ext_info[index_2D] := (val * sign)
      $while (col < range_minus_1)
    }
    $while (row < nrows_minus_1)
  }
}
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$module [initInputs]
$in ()
$out ( nrows : $uint<16>   ncols : $uint<16>   ncol_ind : $uint<16>   maxNitr : $uint<16>   ebbyNo : $float<8,23>   rate : $float<8,23>  )
$is
{
  maxNitr := maxNitr_in
  ebbyNo := ebbyNo_in
  nrows := matrix_in
  ncols := matrix_in
  ncol_ind := matrix_in
  range := (ncol_ind + nrows)
  $branchblock [matrixRead]
  {
    range_min_1 := (range - 1 )
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    mem[(I + 3 )] := matrix_in
    $while (I < range_min_1)
  }
  rate := rate_in
}
$module [initializeExtrinsicInfo]
$in ( ncol_ind : $uint<16>  )
$out ()
$is
{
  ncol_ind_minus_1 := (ncol_ind - 1 )
  $branchblock [initializeExtrinsicInfo_loop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    ext_info[I] := _f0.00e+0
    $while (I < ncol_ind_minus_1)
  }
}
$module [initializeMessage]
$in ( ncol_ind : $uint<16>  )
$out ()
$is
{
  ncol_ind_minus_1 := (ncol_ind - 1 )
  $branchblock [initializeMessage_loop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    temp0 := (3  + I)
    temp1 := mem[temp0]
    temp2 := (temp1 - 1 )
    val := aPriori[temp2]
    message[I] := val
    $while (I < ncol_ind_minus_1)
  }
}
$module [initialize_aPosteriori]
$in ( ncols : $uint<16>  )
$out ()
$is
{
  ncols_minus_1 := (ncols - 1 )
  $branchblock [initialize_aPosteriori_loop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    aPosteriori[I] := aPriori[I]
    $while (I < ncols_minus_1)
  }
}
$module [initialize_aPriori]
$in ( ncols : $uint<16>   ebbyNo : $float<8,23>   rate : $float<8,23>  )
$out ()
$is
{
  ncols_minus_1 := (ncols - 1 )
  $branchblock [init_aPriori_loop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    temp1 := (rate * ebbyNo)
    temp2 := (temp1 * code_block[I])
    temp3 := (temp2 * ($bitcast ($float<8,23>) _f-4.00e+0 ))
    aPriori[I] := temp3
    $while (I < ncols_minus_1)
  }
}
$module [readCodeBlock]
$in ( ncols : $uint<16>  )
$out ()
$is
{
  ncols_minus_1 := (ncols - 1 )
  $branchblock [readCodeBlockLoop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    code_block[I] := code_block_in
    $while (I < ncols_minus_1)
  }
}
$module [updateMessage]
$in ( nrows : $uint<16>   ncol_ind : $uint<16>  )
$out ()
$is
{
  $storage  range : $uint<16> // memory space index = 13  base address = 0  word size = 16
  // can point into  foreign( $void )
  nrows_minus_1 := (nrows - 1 )
  $branchblock [updateMessage_loop1]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi row := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  Nrow $on $loopback // type of target is $uint<16>
    $endmerge
    Nrow := (row + 1 )
    temp00 := (3  + ncol_ind)
    temp01 := (temp00 + row)
    CHECK_BIT_COUNT1 := (ncol_ind - (mem[temp01] - 1 ))
    temp10 := (3  + ncol_ind)
    temp11 := (temp10 + row)
    temp12 := (1  + temp11)
    CHECK_BIT_COUNT2 := (mem[temp12] - mem[temp11])
    $guard (nrows_minus_1) range := CHECK_BIT_COUNT1
    $guard ( ~ nrows_minus_1) range := CHECK_BIT_COUNT2
    range_minus_1 := (range - 1 )
    $branchblock [updateMessage_loop2]
    {
      $dopipeline $depth 7 $buffering 1
      $merge $entry $loopback 
      $phi col := 				  ($bitcast ($uint<16>) 0  ) $on $entry				  Ncol $on $loopback // type of target is $uint<16>
      $endmerge
      Ncol := (col + 1 )
      index_2D := ((mem[((3  + ncol_ind) + row)] - 1 ) + col)
      index_1D := (mem[(3  + index_2D)] - 1 )
      message[index_2D] := (aPosteriori[index_1D] - ext_info[index_2D])
      $while (col < range_minus_1)
    }
    $while (row < nrows_minus_1)
  }
}
$module [update_aPosteriori]
$in ( ncol_ind : $uint<16>  )
$out ()
$is
{
  ncol_ind_minus_1 := (ncol_ind - 1 )
  $branchblock [update_aPosteriori_loop]
  {
    $dopipeline $depth 7 $buffering 1
    $merge $entry $loopback 
    $phi I := 			  ($bitcast ($uint<16>) 0  ) $on $entry			  NI $on $loopback // type of target is $uint<16>
    $endmerge
    NI := (I + 1 )
    val := (mem[(3  + I)] - 1 )
    temp := (aPosteriori[val] + ext_info[I])
    aPosteriori[val] := temp
    $while (I < ncol_ind_minus_1)
  }
}
// Memory space 0: mem 
// Memory space 1: code_block 
// Memory space 2: aPriori 
// Memory space 3: aPosteriori 
// Memory space 4: message 
// Memory space 5: ext_info 
// Memory space 6: %checkNodeComputeEngine:val 
// Memory space 7: %checkNodeComputeEngine:sign 
// Memory space 8: %checkNodeComputeEngine:flag 
// Memory space 9: %checkNodeComputeEngine:exor 
// Memory space 10: %checkNodeComputeEngine:range 
// Memory space 11: %checkNodeComputeEngine:temp1 
// Memory space 12: %checkIsdecoded:is_decoded_temp 
// Memory space 13: %updateMessage:range 
