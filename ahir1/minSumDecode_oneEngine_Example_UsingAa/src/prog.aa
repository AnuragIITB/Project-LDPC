$parameter MATRIX_NNZ         60000
$parameter MATRIX_ORDER       13000


$storage mem : $array [ MATRIX_NNZ ] $of $uint<16>
$storage code_block : $array [ MATRIX_ORDER ] $of $float<8,23>
$storage aPriori    : $array [ MATRIX_ORDER ] $of $float<8,23>
$storage aPosteriori    : $array [ MATRIX_ORDER ] $of $float<8,23>
$storage message : $array [ MATRIX_NNZ ] $of $float <8,23>
$storage ext_info : $array [ MATRIX_NNZ ] $of $float <8,23>


$pipe maxNitr_in : $uint<16>
$pipe ebbyNo_in  : $float<8,23>
$pipe matrix_in : $uint<16>  $depth 2
$pipe rate_in  : $float<8,23>
$pipe code_block_in: $float<8,23> $depth 2
$pipe code_block_out: $float<8,23> 
$pipe Nitr_required : $uint<8>

$module [initInputs] $in () $out (nrows ncols ncol_ind maxNitr: $uint<16> ebbyNo rate: $float<8,23>) $is
{
	maxNitr := maxNitr_in
	ebbyNo := ebbyNo_in
	nrows := matrix_in
	ncols := matrix_in
	ncol_ind := matrix_in
	range := (ncol_ind + nrows)

	$branchblock [matrixRead] {

		range_min_1 := (range - 1)
		$dopipeline $depth 7 $buffering 1

			$merge $entry $loopback
				$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge 
			NI := (I+1)
			mem[(I+3)] := matrix_in

		$while (I < range_min_1)
	}
	rate := rate_in
}


//
// reading code block to decode
$module [readCodeBlock] $in (ncols: $uint<16>) $out () $is
{
	ncols_minus_1 := (ncols - 1)
	$branchblock [readCodeBlockLoop] {
		$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
				$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge 
			NI := (I + 1)
			code_block[I] := code_block_in
		$while (I < ncols_minus_1)
	}
}

//
//---------------------------------------------------------------------------------------------- 





$module [initialize_aPriori] $in (ncols: $uint<16> ebbyNo rate: $float<8,23>) $out() $is
{

	ncols_minus_1 := (ncols - 1)
	$branchblock [init_aPriori_loop] {
		$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
				$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge
			NI := (I + 1)
			temp1 := (rate * ebbyNo) 
			temp2 := (temp1 * code_block[I])
			temp3 :=  (temp2 * ($bitcast ($float<8,23>) _f-4.00e+0) )
			aPriori[I] := temp3 
		$while (I < ncols_minus_1)	
		}
}

$module [initializeMessage] $in ( ncol_ind: $uint<16>  ) $out() $is
{

	ncol_ind_minus_1 := (ncol_ind - 1)
	$branchblock [initializeMessage_loop] {
		$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
				$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge
			NI := (I + 1)
			temp0 := (3 + I) 
			temp1 := mem[ temp0 ]
			temp2 := ( temp1 - 1 )
			val := aPriori[ temp2 ]
			message[I] := val 
		$while (I < ncol_ind_minus_1)	
		}
}


$module [initialize_aPosteriori] $in (ncols: $uint<16>) $out() $is
{

	ncols_minus_1 := (ncols - 1)
	$branchblock [initialize_aPosteriori_loop] {
		$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
				$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge
			NI := (I + 1)
			aPosteriori[I] := aPriori[I] 	
		$while (I < ncols_minus_1)	
		}
}


$module [initializeExtrinsicInfo] $in ( ncol_ind: $uint<16>  ) $out() $is
{

	ncol_ind_minus_1 := (ncol_ind - 1)
	$branchblock [initializeExtrinsicInfo_loop] {
		$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
				$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge
			NI := (I + 1)
			ext_info[I] := _f0.00e+0
		$while (I < ncol_ind_minus_1)	
		}
}


$module [checkNodeComputeEngine] $in (ncol_ind nrows: $uint<16> ) $out() $is
{
		$storage val :  $float<8,23>  
		$storage sign:  $float<8,23>  
		$storage flag:  $uint<1>  
		$storage exor:  $uint<1> 
		$storage range: $uint<16>
		$storage temp1:  $float<8,23>
	//	$storage float_zero:$float<8,23>

	nrows_minus_1 := (nrows - 1)
	$branchblock [checkNodeComputeEngine_loop1] {
	$dopipeline $depth 7 $buffering 1 
	$merge $entry $loopback 
	$phi row := ($bitcast ($uint<16>) 0) $on $entry Nrow $on $loopback
	$endmerge
	Nrow := (row + 1)
	temp00 := (3 + ncol_ind )
	temp01 := ( temp00 + row )
	CHECK_BIT_COUNT1 := (ncol_ind - ( mem[temp01] -1 ) )	
	temp10 := (3 + ncol_ind )
	temp11 := ( temp10 + row )
	temp12 := ( 1 + temp11 )
	CHECK_BIT_COUNT2 := (mem[temp12] - mem[temp11])
	
	
	condition_range := (row == nrows_minus_1)
	$guard (condition_range)  range := CHECK_BIT_COUNT1 
	$guard (~condition_range) range := CHECK_BIT_COUNT2 
	
		range_minus_1 := (range- 1)
		$branchblock [checkNodeComputeEngine_loop2] {
		$dopipeline $depth 7 $buffering 1 
		$merge $entry $loopback 
		$phi col := ($bitcast ($uint<16>) 0) $on $entry Ncol $on $loopback
		$endmerge
		Ncol := (col + 1)
		temp20 := (3 + ncol_ind )
		temp21 := (temp20 + row )
		index_2D := ((mem[temp21] -1) + col )
		val := _f0.00e+0 
		sign:= _f0.00e+0
		flag:= 0
		exor:= 0  
			$branchblock [checkNodeComputeEngine_loop3] {
			$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
			$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
			$endmerge
			NI := (I + 1)
			index := ( (mem[((3 + ncol_ind) + row)] -1) + I )
			mod_temp30 := ( message[index] * ($bitcast ($float<8,23>) _f-1.00e+0) )
		//	float_zero :=  _f0.00e+0
			condition_message := (message[index] < 0) 
			$guard (condition_message) temp1 := mod_temp30
			$guard (~condition_message) temp1 := message[index]			
				condition_I := (I==col)
				condition_flag := (flag == 0)
				condition_swap := ( temp1 < val )
				condtion_exor_1 := ((~condition_I) &condition_message)
				condtion_val_init := ((~condition_I) & condition_flag ) 
				condtion_val_swap_par :=     ( ( ~condition_I) & condition_swap ) 
				condtion_val_swap := ((~condition_flag) & condtion_val_swap_par ) 
				$guard (condtion_exor_1) exor := (exor^1)
				$guard (condtion_val_init) val:= temp1
				$guard (condtion_val_init) val:= temp1
			flag := 1 
			$while (I < range_minus_1)	
			}
			condition_sign := (exor == 0)
			$guard (condition_sign)  	sign := _f1.00e+0
			$guard (~condition_sign)	sign := _f-1.00e+0 
			ext_info[ index_2D ] := ( val * sign )
		$while (col < range_minus_1)	
		}
	
	$while (row < nrows_minus_1)	
	}
}



$module [update_aPosteriori] $in (ncol_ind: $uint<16>) $out() $is
{

	ncol_ind_minus_1 := (ncol_ind - 1)
	$branchblock [update_aPosteriori_loop] {
	$dopipeline $depth 7 $buffering 1 
	$merge $entry $loopback 
	$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
	$endmerge
	NI := (I + 1)
	//
	val := ( mem[(3+I)]-1 )
	temp := ( aPosteriori[val] + ext_info[I] ) 
	aPosteriori[val] := temp 
	//
	$while (I < ncol_ind_minus_1)	
	}
}



$module [checkIsdecoded] $in (ncols: $uint<16>) $out( is_decoded: $uint<1>) $is
{
	$storage is_decoded_temp : $uint<1>
	is_decoded_temp := 1
	
	ncols_minus_1 := (ncols - 1)
	$branchblock [checkIsdecoded_loop] {
	$dopipeline $depth 7 $buffering 1 
	$merge $entry $loopback 
	$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
	$endmerge
	NI := (I + 1)
	c_aPosteriori := (aPosteriori[I] > 0)
	c_code_block  := (code_block[I] < 0)
	c_is_decoded0_1 :=  ((~c_code_block) & c_aPosteriori) 
	c_is_decoded0_2 :=  ((~c_aPosteriori) & c_code_block)
	c_is_decoded0 := ( c_is_decoded0_1 | c_is_decoded0_2 )
	$guard (c_is_decoded0) is_decoded_temp := 0
	$guard (c_code_block) code_block[I] := _f1.00e+0
	$guard (~c_code_block) code_block[I] := _f-1.00e+0
	
	$while (I < ncols_minus_1)	
	}
	is_decoded := is_decoded_temp 
}


$module [updateMessage] $in (nrows ncol_ind: $uint<16>) $out() $is
{
	$storage range : $uint<16>
	nrows_minus_1 := (nrows - 1)
	$branchblock [updateMessage_loop1] {
	$dopipeline $depth 7 $buffering 1 
			$merge $entry $loopback 
				$phi row := ($bitcast ($uint<16>) 0) $on $entry Nrow $on $loopback
			$endmerge
Nrow := (row + 1)
	temp00 := (3 + ncol_ind )
	temp01 := ( temp00 + row )
	CHECK_BIT_COUNT1 := (ncol_ind - ( mem[temp01] -1 ) )	
	temp10 := (3 + ncol_ind )
	temp11 := ( temp10 + row )
	temp12 := ( 1 + temp11 )
	CHECK_BIT_COUNT2 := (mem[temp12] - mem[temp11])
	$guard (nrows_minus_1) range := CHECK_BIT_COUNT1
	$guard (~nrows_minus_1) range := CHECK_BIT_COUNT2
		
		range_minus_1 := (range - 1)
		$branchblock [updateMessage_loop2] {
		$dopipeline $depth 7 $buffering 1 
		$merge $entry $loopback 
		$phi col := ($bitcast ($uint<16>) 0) $on $entry Ncol $on $loopback
		$endmerge
		Ncol := (col + 1)
		//
		index_2D := ( (mem[((3 + ncol_ind) + row)] -1 )+ col )
		index_1D := ( mem [(3 + index_2D)] - 1 )
		message [ index_2D ] := ( aPosteriori[index_1D] - ext_info [index_2D] )
		//
		$while (col < range_minus_1)	
		}
	$while (row < nrows_minus_1)	
	}
}

/*
module [send_outputs] $in(ncols: $uint<16> nitr : $uint<8>) $out() $is
{

	ncols_minus_1 := (ncols - 1)
	$branchblock [send_outputs_loop] {
	$dopipeline $depth 7 $buffering 1 
	$merge $entry $loopback 
	$phi I := ($bitcast ($uint<16>) 0) $on $entry NI $on $loopback
	$endmerge
	NI := (I + 1)
	//
	val := code_block[I]
	code_block_decoded := val 
	//
	$while (I < ncols_minus_1)	
	}
	Nitr_required := nitr 
}
*/


$module [minSumDecode] $in () $out () $is
{
	$branchblock[loop] 
	{
	    $merge $entry loopback $endmerge

		$call initInputs () (nrows ncols nol_ind maxNitr ebbyNo rate)
		$call readCodeBlock (ncols) ()
		$call initialize_aPriori (ncols ebbyNo rate) ()
		$call initializeMessage (ncol_ind) ()

		$storage nitr : uint<8> := 1 
	
	$branchblock[minSumDecode_loop] 
		{
		$merge $entry loopback $endmerge
		
		$call initialize_aPosteriori ( ncols) () 
		$call initializeExtrinsicInfo (ncol_ind) ()
	
		$call checkNodeComputeEngine (ncol_ind nrow) ()
	
		$call update_aPosteriori(ncol_ind) ()
	
		$call checkIsdecoded(ncols) (is_decoded)
		
		nitr++ 
		exit_condition := ((nitr > maxNitr) | (is_decoded==1) ) 
		$if (~exit_condition) $then
		   $place [minSumDecode_loop]
		 $else
		 	$call updateMessage(nrows ncol_ind) ()
		$endif
		
		}		
			
		//$call send_output (ncols nitr) () 

	}while(1)
}

